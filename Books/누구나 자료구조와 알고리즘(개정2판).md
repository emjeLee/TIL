
# 목차
- [자료 구조가 중요한 까닭](#1장-자료-구조가-중요한-까닭)  
  - [읽기](#읽기) 
  - [검색](#검색)
  - [삽입](#삽입)
  - [삭제](#삭제)
- [빅 오 표기법](#빅-오-표기법)  
- [버블 정렬](#버블-정렬)  
- [선택 정렬](#선택-정렬)  
- [삽입 정렬](#삽입-정렬)
- [스택](#스택)
- [큐](#큐)
- [재귀함수](#재귀함수)
- [연결리스트](#연결리스트)
- [이중연결리스트](#이중-연결-리스트)

# 자료 구조가 중요한 까닭 
### 자료 구조 연산
* 읽기 : 자료 구조 내 특정 위치를 찾아보는 것이다. 배열에서는 특정 인덱스의 값을 찾아보는 것을 뜻 함.  
* 검색 : 자료 구조 내에서 특정 값을 찾는 것이다. 배열에서는 특정 값이 들어 있는지, 그렇다면 어떤 인덱스에 있는지 알아보는 것을 뜻 함.
* 삽입 : 새로운 값을 추가 하는 것이다. 배열이라면 배열 내에 슬롯을 만들어 새 값을 추가하는 것을 뜻 함.
* 삭제 : 값을 제거 하는 것이다. 배열에서는 배열의 값 중 하나를 제거하는 것을 뜻 함.

## 읽기
컴퓨터는 한 단계로 배열에서 읽을 수 있다.
> 프로그램에서 배열을 선언하면 컴퓨터는 프로그램이 쓸 수 있는 연속된 빈 셀들의 집합을 할당한다.  
> 원소 다섯 개를 넣을 배열을 생성하면 컴퓨터는 한 줄에서 5개의 빈 셀 그룹을 찾아 사용자가 사용할 배열로 지정한다.  
> 컴퓨터 메모리 내에 각 셀에는 특정 주소가 있다.  
> 각 셀의 메모리 주소는 앞 셀 주소에서 1씩 증가한다.  
> 컴퓨터는 배열을 할당할 때 어떤 메모리 주소에서 시작하는지도 기록해 둔다.  

## 검색
어떻게 보면 읽기와 반대다. 컴퓨터에 값을 제공하고 그 값이 들어 있는 인덱스를 반환하라고 요청한다.    
컴퓨터는 모든 메모리 주소에 한 번에 접근하지만 각 메모리 주소에 어떤 값이 있는지 바로 알지 못한다.
> 배열에서 특정값을 찾으려면 각 셀을 한번에 하나씩 조사하는 방법밖에 없다.  
> 한 번에 한 셀씩 확인하는 방법을 선형 검색이라 부른다.  
> N개의 셀로 이뤄진 배열은 최대 N개의 단계가 필요하다.

## 삽입
배열 어디에 데이터를 삽압하는가에 따라 효율성이 다르다.
> 배열의 맨 처음이나 중간에 데이터를 삽입하려면 삽입할 공간을 만들기 위해 많은 데이터 조각을 이동 시켜야하므로 단계가 늘어난다. 
> 맨 앞에 삽입할 때 배열 내 모든 값을 한 셀씩 오른쪽으로 옮겨야 하기 때문에 가장 많은 단계가 필요하다.

## 삭제
특정 인덱스의 값을 제거하는 과정이다.
> 중간의 값을 삭제하면 빈 공간을 메꾸기 위해 데이터가 이동된다.
> 첫 번째 원소를 삭제하면 인덱스 0이 비게되고, 남아 있는 모든 원소를 이동시켜 빈 공간을 채워야 한다.

# 빅 오 표기법
```
빅 오 표기법은 상수를 무시한다.  
다양한 차수가 한데 섞여 있을 때 빅 오 표기법은 가장 높은 차수의 N만 고려한다.  
```
빅 오는 특정 방식으로 알고리즘에 필요한 단계 수를 고려함으로써 일관성을 유지한다.  
데이터가 늘어날 때 알고리즘의 성능이 어떻게 바뀌는지를 뜻한다.
- O(N) : 알고리즘에 N단계가 필요.
- O(1) : 데이터 원소가 N개일 때 한 단계만 필요.
  1. "가장 빠른" 알고리즘 유형으로 분류 데이터가 늘어나도 알고리즘의 단계 수는 증가하지 않는다.
  1. 상수 시간을 갖는 알고리즘이라고도 표현한다.
- O(logN) : 데이터가 두 배로 증가할 때마다 한 단계씩 늘어나는 알고리즘.  

원소 개수(N) | O(N) | O(logN)
--------|--------|--------
8|8|3
16|16|4
32|32|5
64|64|6
128|128|7  
---
# 버블 정렬  
  각 패스스루마다 정렬되지 않은 값 중 가장 큰 값, '버블'이 올바른 위치로 가게 된다.

1. 배열내에 연속 된 두 항목을 가르키고 두 항목을 비교한다  
2. 왼쪽값이 오른쪽 값보다 크면 두 항목을 교환한다. (크지 않다면 아무것도 하지 않는다)
3. '포인터'를 오른쪽으로 한 셀씩 옮긴다.
4. 배열 끝까지 / 정렬된 값까지 1단계 ~ 3단계 반복
5. 이제 두 포인터를 다시 배열의 처음 두 값으로 옮겨 1단계 ~ 4단계 반복. 교환이 일어나지 않을때까지 반복한다.

### 버블 정렬의 효율성  
  **O(N²)** (= 이차시간) 

- 비교(comparsion): (N-1)+(N-2)+(N-3)... + 1 번 
- 교환(swap): 최악의 시나리오에서는 비교 할 때마다 
ex) 원소 5개가 역순으로 된 배열에서는 4+3+2+1 = 10번의 비교와 10번의 교환 **총 20단계** 필요  
---
# 선택 정렬

1. 배열의 각 셀을 왼쪽부터 오른쪽 방향으로 확인하면서 어떤 값이 최솟값인지 결정  
    (변수에 들어 있는 값보다 작은 값이 들어 있는 셀을 만나면 변수가 새 인덱스를 가르키도록 값을 변경)  
2. 그 인덱스의 값과 패스스루를 처음 했을 때의 값을 비교 (패스스루가 일어나지 않았다면 0번이 시작이라는 의미이다)  
3. 배열 끝에서 시작하는 패스스루에 도달 할 때까지 1 ~ 2단계 반복

### 선택 정렬의 효율성
 O(N²/2) => **O(N²)**  
- 비교(comparsion): (N-1)+(N-2)+(N-3)... + 1 번의 비교 필요  
- 교환(swap): 한 패스스루 당 최대 1번 
> 버블 정렬과 달리 역순의 배열에서는 비교할 때마다 **빠짐없이 교환을 한 번** 해야한다.  
---
# 삽입 정렬
  O(N² + 2N) => **O(N²)**
1. 첫 번째 패스스루에서 임시로 인덱스1의 값을 삭제 후 임시 변수에 저장한다 (인덱스 1에는 공백이 생긴다)
2. 공백 왼쪽에 있는 각 값을 가져와 임시 변수에 있는 값과 비교하는 시프트 단계를 시작.   
    - 공백 왼쪽에 있는 값이 임시 변수에 있는 값보다 크면 그 값을 오른쪽으로 이동)
    - 값을 오른쪽으로 이동시켰으므로 자연히 공백이 왼쪽으로 옮겨진다.
    - 임시 변수 값보다 작은 값을 만나거나 인덱스 0에 도달해야 단계가 끝난다.
3. 임시 변수 값을 공백에 삽입.
4. 1 ~ 3단계가 하나의 패스스루 배열의 마지막 인덱스에서 패스스루를 시작 할 때까지 반복.
---
# 해시 테이블
- 대부분의 프로그래밍 언어는 해시테이블 이라는 자료구조를 포함하며, 해시테이블에는 빠른 읽기가 있다.
- 좋은 해시 테이블은 많은 메모리를 낭비하지 않으면서 균형을 유지하며 충돌을 피한다.
- 데이터를 쌍으로 저장하므로 데이터를 조직하는 많은 시나리오에 유용하다.
```javascript
const menu = {
    "french fries": 0.75,
    "hamburger": 2.5,
    "hot dog": 1.5,
    "soda": 0.6
  }

  menu["french fries"] // 0.75
```
해시 테이블은 쌍으로 이뤄진 값들의 리스트다. 첫 번째 항목을 **키(key)** 라 부르고, 두 번째 항목을 **값(value)** 이라 부른다. 해시테이블의 값 룩업은 딱 한 단계만 걸리므로 평군적으로 효율성이 O(1)이다.
### 해싱 : 문자를 가져와 숫자로 변환하는 과정
### 해시 함수 : 글자를 특정 숫자로 변환하는 데 사용한 코드
- 해시 함수가 유효하려면 동일한 문자열을 해시 함수에 적용할 때마다 항상 동일한 숫자로 변환해야 한다.
### 해시 테이블 룩업 : 키를 사용해 연관된 값을 찾는다.
- 해시 테이블에서 각 값의 위치는 키로 결정된다. 
- 키가 값의 위치를 결정하므로 어떤 키가 있고 그 키의 값을 찾고 싶으면 키 자체로 값을 어디서 찾을 수 있는지 알 수 있다.
- **거꾸로 값을 이용해 연관된 키를 찾을 때는 해시 테이블의 빠른 룩업 기능을 활용 할 수 없다.**
> 이는 키가 값의 위치를 결정한다는 해시 테이블의 대전제 때문이다.  
> 값으로는 키의 위치를 알아내지 못하니 전부 훑는 것 외에는 키를 쉽게 찾을 방법이 없다.
# 충돌(collisoion)
이미 채워진 셀에 데이터를 추가하는 것  

### 충돌 해결 ?
- 분리 연결법 : 충돌이 발생했을 때 셀에 하나의 값을 넣는 대신 배열로의 참조를 넣는 방법
> 하지만 모든 데이터가 해시 테이블의 한 셀에 들어가게 된다면 해시테이블은 배열보다 나을게 없다. 이 경우 해시 테이블 룩업 성능은 O(N)이 되어버린다. 때문에 충돌이 거의 없도록, O(1)시간 내에 일반적으로 룩업을 수행하도록 디자인해야 한다.

# 효율적인 해시테이블 만드는 법
해시테이블은 이 세 요인에 따라 효율성이 정해진다.
1. 해시 테이블에 얼마나 많은 데이터를 저장하는가
2. 해시 테이블에서 얼마나 맣은 셀을 쓸 수 있는가
3. 어떤 해시 함수를 사용하는가
> 가능한 모든 셀에 데이터를 분산 시키는 함수가 좋다 데이터를 넓게 퍼뜨릴수록 충돌이 적다.

해시테이블에 저장된 데이터가 7개면 셀은 10개여야 한다. 원소를 14개 저장할 생각이라면 셀이 20개가 있어야 하는 등이다 데이터와 셀 간 이러한 비율을 **부하율** 이라 부른다.
---
# 스택
**LIFO** : Last In, First Out   
내부적으로 어떤 데이터 구조를 쓰든 개의치 않는다. LIFO 방식으로 동작하는 데이터 원소들의 리스트면 된다. 따라서 스택은 **추상 데이터 타입**에 속한다.
- 데이터는 스택의 끝에만 삽입/삭제 할 수 있다.
- 스택의 마지막 원소만 읽을 수 있다.
- 임시 데이터를 다뤄야 하는 다양한 알고리즘에서 유용함

# 큐
**FIFO** : First IN, First Out  
극장에 줄 서 있는 사람들을 큐 처럼 생각할 수 있다. 큐 역시 **추상 데이터 타입**
큐의 시작을 앞(front), 큐의 끝을 뒤(back)라 부른다.
- 데이터는 큐의 끝에만 삽입할 슈 있다. (스택과 동일)
- 데이터는 큐의 앞에서만 삭제할 수 있다. (스택과 반대)
- 큐의 앞에 있는 원소만 읽을 수 있다. (스택과 반대)
---
# 재귀함수
- 함수가 자 자신을 호출할 때를 뜻 함.

1. countdown(10)
2. number(값 10이 들어있음)을 console에 출력한다
3. countdown함수가 끝나기 전에 number - 9는 9 이니 number(9)를 호출한다.
4. countdown(9)가 실행된다. 이때 number()는 9를 출력
5. countdown(9)가 끝나기전에 countdown(8)을 호출한다.
6. 반복
```javascript
function countdown(number){
  console.log(number);
  countdown(number-1);
}
```
위와 같은 코드는 무한루프에 빠진다 **기저조건** 이 없기 때문 따라서 아래와같이 기저조건을 하나 넣어준다. 모든 재귀함수에는 무한대로 호출되지않게 하는 기저조건이 적어도 하나는 있어야한다.
```javascript
function countdown(number){
  console.log(number);
  if(number === 0){ // 기저조건
    return;
  } else {
    countdown(number-1);
  }
}
```
## 호출 스택
- 스택을 사용해 어떤 함수를 호출 중인지를 기록 한 것.
factorial 함수는 재귀에 기반해 이뤄지는 계산이다. factorial(1)이 자신의 결과(즉 1)를 factorial(2)에 전달함으로써 이뤄진다. 이후 factorial(2)는 이 1과 2를 곱해서 2를 얻고 이 결과를 factorial(3)에 전달한다. 최종적으로 factorial(3)은 이 결과를 받아 3을 곱해 6이라는 결과를 계산한다.
즉, 재귀함수는 계산된 값을 '부모' 함수에 반환한다. 최초로 호출된 함수가 최종 값을 계산한다.

## 스택 오버플로
무한 재귀에서는 컴퓨터가 반복해서 같은 함수를 호풀 스택에 푸시한다. 단기 메모리에 더 이상 데이터를 저장할 공간이 없을 때까지 호출 스택은 점점 늘어난다. 결국 **스택오버플로** 라는 오류가 발생한다. 컴퓨터는 재귀를 강제로 종료하고 메모리가 다 찼으니 더이상의 함수 호출을 거부한다.
---
# 퀵 정렬
- 매우 빠른 알고리즘의 정렬 알고리즘으로 특히 평균 시나리오에서 효율적이다.
- 최악의 시나리오(역순의배열)에서는 삽입 정렬이나 선택 정렬과 성능이 유사하지만 대부분의 경우 일어나는 평균시나리오에서는 훨씬빠르다.
- 퀵 정렬은 분할이라는 개념에 기반한다.

## 분할
배열을 분할 한다는 것은 배열로부터 피벗(임의의 수)을 가져와 피벗보다 작은 모든 수는 피벗의 왼쪽에, 피벗보다 큰 모든 수는 피벗의 오른쪽에 두는 것이다.
1. 왼쪽 포인터를 한 셀씩 계속 오른쪽으로 옮기면서 피벗보다 크거나 같은 값에 도달하면 멈춘다.
2. 이어서 오른쪽 포인터를 한 셀씩 계속 왼쪽으로 옮기면서 피벗보다 작거나 같은 값에 도달하면 멈춘다. 또는 배열 맨 앞에 도달해도 멈춘다.
3. 오른쪽 포인터가 멈춘 후에는 둘 중 하나를 선택해야 한다. 왼쪽 포인터가 오른쪽 포인터에 도달했으면 4단계로 넘어간다. 그렇지 않으면 왼쪽 포인터와 오른쪽 포인터가 가리키고 있는 값을 교환한 후 1,2,3단계를 반복한다.
4. 끝으로 왼쪽 포인터가 현재 가리키고 있는 값과 피벗을 교환한다.

## 퀵 정렬의 효율성
한 번 분할할 때의 효율성을 밝혀야 한다. 분할에 필요한 단계를 분휴해 보면 단계가 두 종류임을 알 수 있다.
- 비교 : 각 값과 피벗을 교환한다.
- 교환 : 적절한 때에 왼쪽과 오른쪽 포인터가 가리키고 있는 값을 교환한다.

각 분할마다 배열 내 각 원소를 피벗과 비교하므로 최소 N번 비교한다. 분할을 한 번 할 때마다 왼쪽과 오른쪽 포인터가 서로 만날 때까지 매 셀을 이동하기 때문이다.  
대부분의 경우 매 단계마다 교환이 일어나지는 않는다. 무작위로 정렬된 데이터가 있을 때, 일반적으로 대략 값의 반 정도만 교환한다. 즉, 평균적으로 N/4번 정도 교환한다.
- 한번 분할 할 때의 효율성  
  평균적으로 N번 비교하고, N/4번 교환한다. 즉, 데이터 원소가 N개일 때 대략 1.25N단계가 걸린다. O(N)시간에 분할을 실행.

  ---
  # 연결리스트
  배열과 마찬가지로 항목의 리스트를 표현하는 자료구조.
  - 메모리 곳곳에 흩어진 연결된 데이터를 **노드**라고 부른다.
  - 각 노드에는 다음 노드의 메모리 주소도 포함된다. 다음 노드의 메모리 주소로의 포인터를 **링크**라고 부른다.
  - 연결리스트의 첫번째 노드를 head, 마지막 노드를 tail이라고도 부른다.
  - 데이터가 컴퓨터 메모리 전체에 흩어질 수 있다는 점에서 연결리스트가 배열보다 유리할 수 있다.
  - 연결리스트를 다룰 땐ㄴ 첫 번째 노드에만 즉시 접근할 수 있다.

## 읽기
  연결리스트의 각 노드는 메모리 어디든 있을 수 있기 때문에 한 단계로 바로 찾을 수 없다. 프로그램은 연결리스트의 첫 번째 노드의 메모리 주소만 안다. n번째 노드를 읽으려면 먼저 첫 번째 노드에 접근한다. 이어서 첫 번째 노드의 링크를 따라 두 번째 노드를 가고 그 링크를 따라 다음 노드로 가고를 반복한다.   
  리스트의 마지막 노드를 읽으려면 N단계가 걸린다. 최악의 시나리오가 O(N)이란 점은 배열에 비해 심각한 단점이다.

## 검색
  값을 검색하려면 읽기와 비슷한 과정을 거쳐야 한다. 즉 첫 번째 노드에서 시작해 각 노드의 링크를 따라 다음 노드로 간다.
  그리고 값을 찾을 때 까지 매 값을 검사한다.
  - 읽기와 다른 점은 루프가 특정 인덱스에서 중지되지 않고 value를 찾거나 리스트 끝에 도달할 때까지 실행된다.

## 삽입
  연결리스트는 배열과 달리 리스트 맨 앞에 삽입하는데 딱 한단계 O(1)만 걸린다. 하지만 이론적으로 데이터를 연결 리스트 내 어디에 삽입하든 딱 한 단계만 걸리지만 중간에 삽입 하게 될 경우 먼저 해당 인덱스에 가야하기 때문에 (연결리스트에서의 읽기는 O(N)이 걸린다.) N+1 단계가 걸리니 리스트 앞에 추가하는것이 아니라면 최종적으로는 O(N)단계가 걸린다.
- 배열은 끝에 삽입할 때, 연결리스트는 앞에 삽입할 때 유리하다.

## 삭제 
앞에서 노드를 삭제하려면 한 단계면 된다. 마지막 노드를 삭제하는 경우도 한 단계가 걸린다. 마지막에서 두번째 노드를 가져와 링크를 Null로 만들면 된다. 하지만 리스트 앞에서부터 시작해 노드에 도착할 때 까지 링크를 따라가야하므로 끝에서 두 번째 노드를 가져오는 데 이미 N단계가 걸린다.

---
# 이중 연결 리스트
- 각 노드에 2개의 링크가 있다.한 링크는 다음 노드를 가르키고, 나머지 한 링크는 앞 노드를 가리킨다. 이중 연결 리스트는 첫 번째 노드 외에 마지막 노드도 항상 기록한다.  
- 항상 첫 노드와 마지막 노드를 모두 알고 있으므로 O(1)에 접근 할 수 있다.
- 앞과 뒤로 모두 이동할 수 있다. 마지막 노드에서 첫 번째 노드로 거슬러 올라갈 수도 있다.
- O(1) 시간만에 리스트 끝에 데이터를 삽입하고 리스트 앞에서 데이터를 삭제할 수 있으므로 **큐를 위한 완벽한 내부 자료구조**이다.
  - 큐는 끝에서 삽입하고 앞에서 삭제하므로 내부 자료구조로서 배열이 잘 어울린다. 배열은 끝에 삽이하는데 O(1)이지만 앞에서 삭제하면 O(N)이다. 하지만 이중 연결리스트는 모두 O(1)이다.
