
# 목차
- [자료 구조가 중요한 까닭](#1장-자료-구조가-중요한-까닭)  
  - [읽기](#읽기) 
  - [검색](#검색)
  - [삽입](#삽입)
  - [삭제](#삭제)
- [빅 오 표기법](#빅-오-표기법)  
- [버블 정렬](#버블-정렬)  
- [선택 정렬](#선택-정렬)  
- [삽입 정렬](#삽입-정렬)

# 자료 구조가 중요한 까닭 
### 자료 구조 연산
* 읽기 : 자료 구조 내 특정 위치를 찾아보는 것이다. 배열에서는 특정 인덱스의 값을 찾아보는 것을 뜻 함.  
* 검색 : 자료 구조 내에서 특정 값을 찾는 것이다. 배열에서는 특정 값이 들어 있는지, 그렇다면 어떤 인덱스에 있는지 알아보는 것을 뜻 함.
* 삽입 : 새로운 값을 추가 하는 것이다. 배열이라면 배열 내에 슬롯을 만들어 새 값을 추가하는 것을 뜻 함.
* 삭제 : 값을 제거 하는 것이다. 배열에서는 배열의 값 중 하나를 제거하는 것을 뜻 함.

## 읽기
컴퓨터는 한 단계로 배열에서 읽을 수 있다.
> 프로그램에서 배열을 선언하면 컴퓨터는 프로그램이 쓸 수 있는 연속된 빈 셀들의 집합을 할당한다.  
> 원소 다섯 개를 넣을 배열을 생성하면 컴퓨터는 한 줄에서 5개의 빈 셀 그룹을 찾아 사용자가 사용할 배열로 지정한다.  
> 컴퓨터 메모리 내에 각 셀에는 특정 주소가 있다.  
> 각 셀의 메모리 주소는 앞 셀 주소에서 1씩 증가한다.  
> 컴퓨터는 배열을 할당할 때 어떤 메모리 주소에서 시작하는지도 기록해 둔다.  

## 검색
어떻게 보면 읽기와 반대다. 컴퓨터에 값을 제공하고 그 값이 들어 있는 인덱스를 반환하라고 요청한다.    
컴퓨터는 모든 메모리 주소에 한 번에 접근하지만 각 메모리 주소에 어떤 값이 있는지 바로 알지 못한다.
> 배열에서 특정값을 찾으려면 각 셀을 한번에 하나씩 조사하는 방법밖에 없다.  
> 한 번에 한 셀씩 확인하는 방법을 선형 검색이라 부른다.  
> N개의 셀로 이뤄진 배열은 최대 N개의 단계가 필요하다.

## 삽입
배열 어디에 데이터를 삽압하는가에 따라 효율성이 다르다.
> 배열의 맨 처음이나 중간에 데이터를 삽입하려면 삽입할 공간을 만들기 위해 많은 데이터 조각을 이동 시켜야하므로 단계가 늘어난다. 
> 맨 앞에 삽입할 때 배열 내 모든 값을 한 셀씩 오른쪽으로 옮겨야 하기 때문에 가장 많은 단계가 필요하다.

## 삭제
특정 인덱스의 값을 제거하는 과정이다.
> 중간의 값을 삭제하면 빈 공간을 메꾸기 위해 데이터가 이동된다.
> 첫 번째 원소를 삭제하면 인덱스 0이 비게되고, 남아 있는 모든 원소를 이동시켜 빈 공간을 채워야 한다.

# 빅 오 표기법
```
빅 오 표기법은 상수를 무시한다.  
다양한 차수가 한데 섞여 있을 때 빅 오 표기법은 가장 높은 차수의 N만 고려한다.  
```
빅 오는 특정 방식으로 알고리즘에 필요한 단계 수를 고려함으로써 일관성을 유지한다.  
데이터가 늘어날 때 알고리즘의 성능이 어떻게 바뀌는지를 뜻한다.
- O(N) : 알고리즘에 N단계가 필요.
- O(1) : 데이터 원소가 N개일 때 한 단계만 필요.
  1. "가장 빠른" 알고리즘 유형으로 분류 데이터가 늘어나도 알고리즘의 단계 수는 증가하지 않는다.
  1. 상수 시간을 갖는 알고리즘이라고도 표현한다.
- O(logN) : 데이터가 두 배로 증가할 때마다 한 단계씩 늘어나는 알고리즘.  

원소 개수(N) | O(N) | O(logN)
--------|--------|--------
8|8|3
16|16|4
32|32|5
64|64|6
128|128|7  

# 버블 정렬  
  각 패스스루마다 정렬되지 않은 값 중 가장 큰 값, '버블'이 올바른 위치로 가게 된다.

1. 배열내에 연속 된 두 항목을 가르키고 두 항목을 비교한다  
2. 왼쪽값이 오른쪽 값보다 크면 두 항목을 교환한다. (크지 않다면 아무것도 하지 않는다)
3. '포인터'를 오른쪽으로 한 셀씩 옮긴다.
4. 배열 끝까지 / 정렬된 값까지 1단계 ~ 3단계 반복
5. 이제 두 포인터를 다시 배열의 처음 두 값으로 옮겨 1단계 ~ 4단계 반복. 교환이 일어나지 않을때까지 반복한다.

### 버블 정렬의 효율성  
  **O(N²)** (= 이차시간) 

- 비교(comparsion): (N-1)+(N-2)+(N-3)... + 1 번 
- 교환(swap): 최악의 시나리오에서는 비교 할 때마다 
ex) 원소 5개가 역순으로 된 배열에서는 4+3+2+1 = 10번의 비교와 10번의 교환 **총 20단계** 필요  

# 선택 정렬

1. 배열의 각 셀을 왼쪽부터 오른쪽 방향으로 확인하면서 어떤 값이 최솟값인지 결정  
    (변수에 들어 있는 값보다 작은 값이 들어 있는 셀을 만나면 변수가 새 인덱스를 가르키도록 값을 변경)  
2. 그 인덱스의 값과 패스스루를 처음 했을 때의 값을 비교 (패스스루가 일어나지 않았다면 0번이 시작이라는 의미이다)  
3. 배열 끝에서 시작하는 패스스루에 도달 할 때까지 1 ~ 2단계 반복

### 선택 정렬의 효율성
 O(N²/2) => **O(N²)**  
- 비교(comparsion): (N-1)+(N-2)+(N-3)... + 1 번의 비교 필요  
- 교환(swap): 한 패스스루 당 최대 1번 
> 버블 정렬과 달리 역순의 배열에서는 비교할 때마다 **빠짐없이 교환을 한 번** 해야한다.  

# 삽입 정렬
  O(N² + 2N) => **O(N²)**
1. 첫 번째 패스스루에서 임시로 인덱스1의 값을 삭제 후 임시 변수에 저장한다 (인덱스 1에는 공백이 생긴다)
2. 공백 왼쪽에 있는 각 값을 가져와 임시 변수에 있는 값과 비교하는 시프트 단계를 시작.   
    - 공백 왼쪽에 있는 값이 임시 변수에 있는 값보다 크면 그 값을 오른쪽으로 이동)
    - 값을 오른쪽으로 이동시켰으므로 자연히 공백이 왼쪽으로 옮겨진다.
    - 임시 변수 값보다 작은 값을 만나거나 인덱스 0에 도달해야 단계가 끝난다.
3. 임시 변수 값을 공백에 삽입.
4. 1 ~ 3단계가 하나의 패스스루 배열의 마지막 인덱스에서 패스스루를 시작 할 때까지 반복.






